---
layout: post
title: "What’s Not Necessarily Wrong With Ruby"
published: 1
category: "Ancient Archives"
---
<p><a href="http://www.bitwisemag.com/2/What-s-Wrong-With-Ruby">Bitwise</a> introduces <a href="http://www.bitwisemag.com/2/What-s-Wrong-With-Ruby">'What‚Äôs Wrong With Ruby?'</a> with</p>

<blockquote>Matthew Huntbach takes a long hard look at the coolest language on the planet and is distinctly under impressed by what he sees‚Ä¶</blockquote>

<p>That introduction has more than a slight aroma of flamebait. In the actual article Mr Huntbach concludes:</p>

<blockquote>Despite what I‚Äôve written above, I didn‚Äôt find Ruby horrible. If I needed to use a scripting language, it‚Äôs the one I would now use. It‚Äôs cleaner than Perl, and I like its syntax better than Python. Its object-based nature works for me: object-orientation is not the silver bullet, but it is a better abstraction for managing complexity and modelling things than anything else we have. It has picked up some useful aspects from functional programming as well and put them into a language whose ability to handle interaction between stateful objects makes it more practical than pure functional programming (still to me, real elegance, but of an infuriating kind). But it isn‚Äôt as revolutionary or as cool as its advocates suppose.</blockquote>

<p>I can't disagree with that at all. Ruby is generating a lot of hype because it can trigger great enthusiasm from the hordes of recently converted PHP and Java programmers. Ruby can also support trendy new paradigms like meta-programing, <a href="http://behaviour-driven.org/">BDD</a> and <a href="http://en.wikipedia.org/wiki/Domain-specific_programming_language">domain-specific languages</a> with ease, so tends to get caught up in all the Cool New Development trends. It's zeitgeisty!</p>

<p>Skip over the academic language snobbery (that's a whole topic in itself...) and there's nothing really objectionable about the article at all. I find the description of a conference full of programing academics quivering with confusion about the ungodly goings on the real world rather amusing.  <em>People are using </em><strong><em>scripting</em></strong><em> languages!</em> <em>Oh my goodness! Why won't they listen to us?</em></p>

<p>I disagree with Matthew Huntbach's criticism of Ruby's array handling as unintuitive, however.</p>

<blockquote>I‚Äôll give just a couple of examples. In Ruby, if a is [1,2,3] and b is [10,20,30], then a+b is [1,2,3,10,20,30]. Why not [11,22,33], which Tim Sweeney in an earlier article suggests "intuitively makes sense"? What does a[x,y] (when a is a two-dimensional array) mean in Ruby? Not what I first supposed it might mean from other languages (otherwise a[x][y]), or even what I then thought it might mean (otherwise a[x..y]).</blockquote>

<p>The plus sign has this functionality for Ruby arrays (all operators are just object methods in Ruby):</p>

<p><code>[1, 2, 3]  +  [4, 5, 6]
=&gt; [1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6] - [3, 1, 6]
=&gt; [2, 4, 5]</code>
<code>[ 1, 2, 3 ] * 3
=&gt; [1, 2, 3, 1, 2, 3, 1, 2, 3]</code>
Ruby's array is a<em> list</em> that can contain any mix of objects. The plus operator is a method acting on the list object, not its contents. The least surprising results of adding two lists is a longer list, hence the default, sugary behaviour of plus.</p>

<p>Matthew Huntbach would get the behaviour he wanted by using the correct classes, Vector and Matrix.</p>

<p><code>a = Vector[1, 2, 3]
b = Vector[4, 5, 6]
a + b
=&gt; [5, 7, 9]</code>
If you want to apply a method to the <em>contents</em> of an object, use a map or collection method. Ruby excels at this. One of the reasons Ruby makes me happy is that its array handling is so much more convenient than Perl's.</p>

<p>Ruby's behaviour will not always be "intuitive" if you've spent years working with C based languages, but I think this more often just down to unlearning old habits than flaws in the language itself.  Ruby quite deliberately dumps the non-OOP baggage of C based languages. Ruby was written as a replacement for Perl but is not conceptually descended from Perl, or from C. Its <em>purpose</em> was modelled on Perl, but it's ancestry is more closely linked to Lisp and Smalltalk.</p>

<p>Although I think Ruby succeeded in following the principle of least surprise<em> in most cases</em> its fundamental differences from the C based languages do cause a few points of confusion. My own favourite is Ruby's evaluation of "truthiness".</p>

<p>In most C-based languages 0, "", undefined are false. Anything else is true.</p>

<p><code>$result = 0;
print "Hello" if $result;
=&gt;</code>
In Ruby only Falseclass and Nilclass are false. Any other defined object is true, including 0 and empty strings.</p>

<p><code>result = 0
print "Hello" if result
=&gt; "hello"</code>
(Both approaches are justifiable but I'm now happier with Ruby's approach. 0 and "" are still, present valid data. In my contrived example above 0 is still a result)</p>

<p>Another gotcha is that every named variable is effectively containing a reference to the actual object. By default assignment copies the reference, not the object.</p>

<p><code>a = "HELLO"
b = a
a =&gt; "HELLO"
b =&gt; "HELLO"</p>

<p>a.downcase!
a =&gt; 'hello'
b =&gt; 'hello'</code>
This is rarely a problem but occasional use of .dup is required.</p>

<p><strong>Update:</strong> If you want to read more interesting responses to the Bitwise article then take a look at <a href="http://redhanded.hobix.com/cult/whatSWrongWithRubyHahYeahItSMe.html">Why's admission that yes, he is what's wrong with Ruby</a>, and make sure you read the comments.</p>

<blockquote>This all coming from a guy whose current interest is the Aldwych programming language.</blockquote>

<p>Ouch.</p>

<p><strong>Update: </strong> <a href="http://www.bitwisemag.com/2/Ruby-s-Inferiority-Complex">Storm in teacup continues at Bitwise</a>!</p>


